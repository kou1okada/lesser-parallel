#!/usr/bin/env bash

# Lesser Parallel
# Copyright (c) 2014 Koichi OKADA. All rights reserved.
# The official repository is:
# https://github.com/kou1okada/lesser-parallel
# This script is distributed under the MIT license.
# http://www.opensource.org/licenses/mit-license.php

LESSER_PARALLEL_MAX_JOBS=${LESSER_PARALLEL_MAX_JOBS:-8}

function lesser-parallel-get-jobs-count ()
#   Get number of current runnning jobs.
{
  jobs -l >/dev/null
  jobs -l | wc -l
}

function lesser-parallel-restrict-jobs-count () # <maxjobs>
#   Wait the number of running jobs will be reduced
#   if the number of current runnning jobs is over <maxjobs>.
{
  while (( $1 <= $(lesser-parallel-get-jobs-count) )); do
    sleep 0.2
  done
}

function lesser-parallel () # [<command> [<arguments> ...]] < <list_to_arguments>
#   Execute <command> by parallel.
# Arguments:
#   Each jobs receive input line from STDIN into placeholders.
#   Placeholders will be substituted with input line as below:
#   {}   : Input line.
#   {.}  : Input line without extention (pathname).
#   {/}  : Input line without directory (basename).
#   {//} : Input line without basename (dirname).
#   {/.} : Input line without directory and extension (basename without suffix).
#   {#}  : Job sequence number of paralell.
{
  local cmd arg line basename ext PARALLEL_SEQ=1
  while read line; do
    basename="$(basename "$line")"
    ext="${basename##*.}"
    [[ "$ext" == "$basename" ]] && ext=""
    [[ "$ext" != "" ]] && ext=".$ext"
    cmd=( )
    for arg; do
      case "$arg" in
      "{}")   cmd+=( "$line" ) ;;
      "{.}")  [[ -z "$ext" ]] && cmd+=( "$line" ) || cmd+=( "${line%.*}" ) ;;
      "{/}")  cmd+=( "$basename" ) ;;
      "{//}") cmd+=( "$(dirname "$line")" ) ;;
      "{/.}") cmd+=( "$(basename "$basename" "$ext")" ) ;;
      "{#}")  cmd+=( "$PARALLEL_SEQ" ) ;;
      *)      cmd+=( "$arg" ) ;;
      esac
    done
    
    lesser-parallel-restrict-jobs-count $LESSER_PARALLEL_MAX_JOBS
    
    "${cmd[@]}" &
    let PARALLEL_SEQ++
  done
  
  lesser-parallel-restrict-jobs-count 1
}

#/Lesser Parallel

function lesser-parallel-help ()
{
  cat <<-EOD
	Usage:
	  ${SCRIPTNAME} [<options>] [<command> [<arguments> ...]] < <list_to_arguments>
	  cat ... | ${SCRIPTNAME} [<options>] [<command> [<arguments> ...]]
	Options:
	  -j <n>      : Run <n> jobs in parallel.
	  -e [<file>] : Embed Lesser Parallel to <file>.
	  -h, --help  : Display help and ext.
	Arguments:
	  Each jobs receive input line from STDIN into placeholders.
	  Placeholders will be substituted with input line as below:
	  {}   : Input line.
	  {.}  : Input line without extention (pathname).
	  {/}  : Input line without directory (basename).
	  {//} : Input line without basename (dirname).
	  {/.} : Input line without directory and extension (basename without suffix).
	  {#}  : Job sequence number of paralell.
	
	EOD
}

function lesser-parallel-embed () # [<target file>]
#   Display lesser-parallel for embed or embed it into <target file>.
#   <target file> must have embedding markers.
{
  local LINES="$(wc -l < "$SCRIPTFILE")"
  local code
  code="$(grep -A "$LINES" "^# Lesser Parallel" "$SCRIPTFILE" \
         | grep -B "$LINES" "^#/Lesser Parallel" \
         | awk '{print $0 ($0 ~ /^#[ /]Lesser Parallel/ ? " for Embedding" : "")}')" #"
  if [[ -f "$1" ]]; then
    awk -v code="$code" '
      /^# Lesser Parallel for Embedding/ {embedded = embed = 1; print code}
      !embed {print $0}
      /^#\/Lesser Parallel for Embedding/ {embed = 0}
      END {exit embedded != 1}
    ' "$1" > "$1.tmp$$"
    if (( $? == 0 )); then
      mv "$1" "$1.$(date -d "$(stat "$1" -c %y)" "+%Y%m%d_%H%M%S")~"
      mv "$1.tmp$$" "$1"
      echo "Lesser Parallel is Embedded to $1."
    else
      echo "$1 has no embeddig markers."
    fi
  else
    echo "$code"
  fi
}

SCRIPTNAME="${0##*/}"
SCRIPTFILE="$(realpath "$(which $0)")"

while (( 0 < $# )); do
  if (( ${#ARGS[@]} == 0 )); then
    case "$1" in
    -j)
      LESSER_PARALLEL_MAX_JOBS="$2"
      shift 2 || break
      ;;
    -e)
      lesser-parallel-embed "$2"
      exit
      ;;
    -h|--help)
      lesser-parallel-help
      exit
      ;;
    *)
      ARGS+=( "$1" )
      shift
      ;;
    esac
  else
    ARGS+=( "$1" )
    shift
  fi
done

if (( ${#ARGS[@]} <= 0 )); then
  lesser-parallel-help
  exit 1
fi >&2

lesser-parallel "${ARGS[@]}"
